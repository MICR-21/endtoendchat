const express = require("express");
const http = require("http");
const socketIo = require("socket.io");
const cors = require("cors");
const { subtle } = require("node:crypto").webcrypto;
const { MessengerClient } = require("./messenger");
const {
    generateECDSA,
    generateEG,
    signWithECDSA,
    cryptoKeyToJSON,
} = require("./lib");

const app = express();
const server = http.createServer(app);
const io = socketIo(server, {
    cors: {
        origin: "http://127.0.0.1:5500",
        methods: ["GET", "POST"],
    },
});
const fs = require("fs");
const certificatesFile = "certificates.json";
const connectionsFile = "connections.json";

app.use(cors({ origin: "http://127.0.0.1:5500" }));
app.use(express.static("public")); // Serve static files from the "public" directory

// Store active users and their data
const users = {}; // { username: { socket, client, cert, certSignature } }

let caKeyPair;
let govKeyPair;

(async () => {
    // Generate the Certificate Authority and Government key pairs
    // generated by clients before relaying them to other clients
    caKeyPair = await generateECDSA();
    // keypair for the government to be able to decrypt all messages
    govKeyPair = await generateEG();
})();

// Utility to ensure a key is ECDH-compatible
async function ensureECDHKey(key) {
    try {
        return await subtle.importKey(
            "jwk",
            await cryptoKeyToJSON(key),
            { name: "ECDH", namedCurve: "P-384" },
            true,
            []
        );
    } catch (err) {
        throw new Error(`Invalid ECDH key: ${err.message}`);
    }
}
const stringifyCert = function (cert) {
    if (typeof cert === "object") {
        return JSON.stringify(cert);
    } else if (typeof cert === "string") {
        return cert;
    } else {
        throw new Error("Certificate is not a JSON or string");
    }
};

// Handle user connections
io.on("connection", (socket) => {
    console.log("A user connected.");

    // Handle user registration
    socket.on("register", async (username) => {
        if (users[username]) {
            // Reconnection scenario
            console.log(`User ${username} reconnected.`);
            users[username].socket = socket; // Update the socket reference
            socket.emit("registered", {
                cert: users[username].cert,
                certSignature: users[username].certSignature,
            });

            // Send the user list to the reconnected user
            const userList = Object.keys(users).filter(
                (user) => user !== username
            );
            socket.emit("userList", userList);
            return;
        }

        // Handle first-time registration
        console.log(`Registering new user: ${username}`);
        const client = new MessengerClient(caKeyPair.pub, govKeyPair.pub);
        const cert = await client.generateCertificate(username);
        const certSignature = await signWithECDSA(
            caKeyPair.sec,
            JSON.stringify(cert)
        );

        users[username] = { socket, client, cert, certSignature };

        // Send certificate and success confirmation
        socket.emit("registered", { cert, certSignature });

        // Notify other users
        for (const user in users) {
            if (user !== username) {
                users[user].socket.emit("userJoined", username);
            }
        }

        // Send the current user list
        const userList = Object.keys(users).filter((user) => user !== username);
        socket.emit("userList", userList);
        console.log("User registered:", username);
    });

    // Handle requests for a certificate
    socket.on("requestCertificate", async ({ from, to }) => {
        if (!users[to]) {
            socket.emit("error", "User not found.");
            return;
        }
        console.log(`Exchanging certificates for ${from} and ${to}...`);
        const recipient = users[to];
        const senderClient = users[from].client;
        await senderClient.receiveCertificate(
            recipient.cert,
            recipient.certSignature
        );
    });

    // Handle sending messages
    socket.on("sendMessage", async ({ from, to, message }) => {
        try {
            if (!users[to]) {
                socket.emit("error", "Recipient not found.");
                return;
            }

            const recipient = users[to];
            const sender = users[from];
            const senderClient = users[from].client;

            // Ensure certificates are exchanged
            if (!senderClient.certs[to]) {
                console.log(`Exchanging certificates for ${from} and ${to}...`);
                await senderClient.receiveCertificate(
                    recipient.cert,
                    recipient.certSignature
                );
            }

            // Debug: Check the sender's and recipient's keys
            console.log(
                "Sender private key:",
                await cryptoKeyToJSON(senderClient.EGKeyPair.sec)
            );
            console.log("Recipient public key (raw):", recipient.cert.pub);

            // Ensure recipient's public key is valid for ECDH
            const recipientPubKey = await ensureECDHKey(recipient.cert.pub);
            console.log(
                "Recipient public key (validated):",
                await cryptoKeyToJSON(recipientPubKey)
            );

            // Send the encrypted message
            const encryptedMessage = await senderClient.sendMessage(
                to,
                message
            );
            console.log(
                `Encrypted message sent from ${from} to ${to}:`,
                encryptedMessage
            );

            // Log before emitting message to recipient
            console.log(
                `Sending encrypted message to recipient socket for user ${to}...`
            );

            // Decrypt the message for the recipient
            const recipientClient = recipient.client;

            // Ensure the recipient's client has the necessary certificate
            if (!recipientClient.certs[from]) {
                console.log(`Exchanging certificates for ${to} and ${from}...`);
                await recipientClient.receiveCertificate(
                    sender.cert,
                    sender.certSignature
                );
            }

            // Decrypt the message
            const plaintext = await recipientClient.receiveMessage(
                from,
                encryptedMessage
            );
            console.log(`Decrypted message for ${to}: ${plaintext}`);

            // Emit the decrypted message to the recipient
            recipient.socket.emit("receiveMessage", {
                from,
                message: plaintext, // Send the plaintext message
            });
        } catch (err) {
            console.error(`Error handling sendMessage: ${err.message}`);
            socket.emit("error", `Failed to send message: ${err.message}`);
        }
    });

    socket.on("receiveMessage", async ({ from, message }) => {
        try {
            const recipientClient = users[from]?.client;
            if (!recipientClient) {
                console.error(`Recipient client not found for ${from}`);
                return;
            }

            console.log(`Message received for ${from} from ${message}`);
            console.log("Attempting to decrypt the message...");

            // Process the message on the recipient's side
            const plaintext = await recipientClient.receiveMessage(
                from,
                message
            );

            console.log(`Decrypted message for ${from}:`, plaintext);

            // Optionally forward the plaintext to the recipient's UI
            const recipientSocket = users[from]?.socket;
            if (recipientSocket) {
                recipientSocket.emit("decryptedMessage", {
                    from,
                    plaintext,
                });
            }
        } catch (err) {
            console.error(
                `Error handling receiveMessage for ${from}: ${err.message}`
            );
        }
    });

    // Handle user disconnection
    socket.on("disconnect", () => {
        const disconnectedUser = Object.keys(users).find(
            (username) => users[username].socket.id === socket.id
        );
        if (disconnectedUser) {
            delete users[disconnectedUser];
            console.log(`${disconnectedUser} disconnected.`);
            io.emit("userLeft", disconnectedUser);
        }
    });
});

// Start the server
const PORT = 3000;
server.listen(PORT, () => {
    console.log(`Server running on http://localhost:${PORT}`);
});
